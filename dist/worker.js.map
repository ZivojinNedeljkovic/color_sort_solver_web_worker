{"mappings":"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","sources":["src/bottle.ts","src/node.ts","src/step.ts","src/solutionSearch.ts","src/game.ts","src/worker.ts"],"sourcesContent":["export type Bottle = string[]\r\n\r\nconst getTopColor = (bottle: Bottle) => bottle[bottle.length - 1]\r\n\r\nexport const isClosedBottle = (bottle: Bottle) =>\r\n  bottle.length === 4 && hasOnlyOneColor(bottle)\r\n\r\nconst canPour = (fromBottle: Bottle, toBottle: Bottle) =>\r\n  fromBottle.length > 0 &&\r\n  toBottle.length < 4 &&\r\n  (getTopColor(fromBottle) === getTopColor(toBottle) ||\r\n    toBottle.length === 0) &&\r\n  !isClosedBottle(fromBottle)\r\n\r\nfunction hasOnlyOneColor(bottle: Bottle) {\r\n  for (const color of bottle) {\r\n    if (color !== bottle[0]) return false\r\n  }\r\n  return true\r\n}\r\n\r\nconst getNumberOfEmptyFields = (bottle: Bottle) => 4 - bottle.length\r\n\r\nconst shodPour = (fromBottle: Bottle, toBottle: Bottle) =>\r\n  !(\r\n    hasOnlyOneColor(fromBottle) &&\r\n    (toBottle.length === 0 ||\r\n      getNumberOfEmptyFields(toBottle) < fromBottle.length)\r\n  )\r\n\r\nexport function pour(fromBottle: Bottle, toBottle: Bottle) {\r\n  if (!(canPour(fromBottle, toBottle) && shodPour(fromBottle, toBottle))) return\r\n  ;[fromBottle, toBottle] = [[...fromBottle], [...toBottle]]\r\n\r\n  do {\r\n    toBottle.push(fromBottle.pop()!)\r\n  } while (canPour(fromBottle, toBottle))\r\n\r\n  return { emptiedBottle: fromBottle, filledBottle: toBottle }\r\n}\r\n\r\nexport const areEqualBottles = (bottle1: Bottle, bottle2: Bottle) => {\r\n  if (bottle1 === bottle2) return true\r\n\r\n  if (bottle1.length !== bottle2.length) return false\r\n\r\n  for (let i = 0; i < bottle1.length; i++) {\r\n    if (bottle1[i] !== bottle2[i]) return false\r\n  }\r\n\r\n  return true\r\n}\r\n","class Node<T> {\r\n  children: Node<T>[] = []\r\n\r\n  constructor(public key: T, public parent: Node<T> | undefined) {}\r\n\r\n  private _hasUniqueKeyInBranch(\r\n    areEqualKeys: (key1: T, key2: T) => boolean,\r\n    ancestorNode: Node<T> | undefined\r\n  ): boolean {\r\n    if (!ancestorNode) return true\r\n\r\n    if (areEqualKeys(this.key, ancestorNode.key)) return false\r\n\r\n    return this._hasUniqueKeyInBranch(areEqualKeys, ancestorNode.parent)\r\n  }\r\n\r\n  hasUniqueKeyInBranch(areEqualKeys: (key1: T, key2: T) => boolean) {\r\n    return this._hasUniqueKeyInBranch(areEqualKeys, this.parent)\r\n  }\r\n\r\n  getBranchKeys() {\r\n    const ancestryKeys: T[] = []\r\n    let branchNode: Node<T> | undefined = this\r\n\r\n    while (branchNode) {\r\n      ancestryKeys.push(branchNode.key)\r\n      branchNode = branchNode.parent\r\n    }\r\n\r\n    return ancestryKeys.reverse()\r\n  }\r\n}\r\n\r\nexport default Node\r\n","import { areEqualBottles, Bottle, isClosedBottle } from './bottle'\r\n\r\nexport type Step = Bottle[]\r\n\r\nexport function areEqualSteps(step1: Step, step2: Step) {\r\n  if (step1.length !== step1.length) return false\r\n\r\n  for (let i = 0; i < step1.length; i++) {\r\n    if (!areEqualBottles(step1[i], step2[i])) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nexport const getNumOfClosedBottles = (step: Step) =>\r\n  step.reduce<number>(\r\n    (sum, bottle) => (isClosedBottle(bottle) ? sum + 1 : sum),\r\n    0\r\n  )\r\n","import { Bottle, pour } from './bottle'\r\nimport { isGameWon } from './game'\r\nimport Node from './node'\r\nimport { areEqualSteps, getNumOfClosedBottles, Step } from './step'\r\n\r\nclass SolutionSearch {\r\n  private bestMoveCount = Number.MAX_SAFE_INTEGER\r\n  private foundASolution = false\r\n  private closedBottlesPreStepInFoundSolution: number[] = []\r\n\r\n  constructor(\r\n    bottles: Bottle[],\r\n    private onFindSolution: (solution: Step[]) => void\r\n  ) {\r\n    this.search(new Node(bottles, undefined))\r\n  }\r\n\r\n  private removeLastAddedNodeFromParent<T>(node: Node<T>) {\r\n    node.parent?.children.pop()\r\n  }\r\n\r\n  private saveSearchProgress(solution: Step[]) {\r\n    this.bestMoveCount = solution.length - 1\r\n    this.closedBottlesPreStepInFoundSolution = solution.map(step =>\r\n      getNumOfClosedBottles(step)\r\n    )\r\n    this.foundASolution = true\r\n  }\r\n\r\n  private madeProgress(step: Step, stepIndex: number) {\r\n    if (!this.foundASolution) return true\r\n    return (\r\n      getNumOfClosedBottles(step) >=\r\n      this.closedBottlesPreStepInFoundSolution[stepIndex]\r\n    )\r\n  }\r\n\r\n  private search(node: Node<Step>, moveCount = 0) {\r\n    const bottles = node.key\r\n    if (\r\n      !(this.foundASolution\r\n        ? this.madeProgress(bottles, moveCount)\r\n        : node.hasUniqueKeyInBranch(areEqualSteps))\r\n    ) {\r\n      this.removeLastAddedNodeFromParent(node)\r\n      return\r\n    }\r\n\r\n    if (isGameWon(bottles) && moveCount < this.bestMoveCount) {\r\n      const solution = node.getBranchKeys()\r\n      this.onFindSolution(solution)\r\n      this.saveSearchProgress(solution)\r\n      return\r\n    }\r\n\r\n    bottles.forEach((fromBottle, i) => {\r\n      bottles.forEach((toBottle, j) => {\r\n        if (i === j) return\r\n\r\n        const changedBottles = pour(fromBottle, toBottle)\r\n\r\n        if (!changedBottles) return\r\n\r\n        const { emptiedBottle, filledBottle } = changedBottles\r\n\r\n        const nextStep = [...bottles]\r\n\r\n        nextStep[i] = emptiedBottle\r\n        nextStep[j] = filledBottle\r\n\r\n        const newNode = new Node(nextStep, node)\r\n\r\n        node.children.push(newNode)\r\n\r\n        this.search(newNode, moveCount + 1)\r\n      })\r\n    })\r\n\r\n    if (node.children.length === 0) this.removeLastAddedNodeFromParent(node)\r\n  }\r\n}\r\n\r\nexport default SolutionSearch\r\n","import { Bottle, isClosedBottle } from \"./bottle\"\r\n\r\n\r\nexport function isGameWon(bottles: Bottle[]) {\r\n  for (const bottle of bottles) {\r\n    if (!(isClosedBottle(bottle) || bottle.length === 0)) return false\r\n  }\r\n\r\n  return true\r\n}\r\n","import { Bottle } from './bottle'\r\nimport SolutionSearch from './solutionSearch'\r\n\r\n// const isArrayOfStrings = (data: any) =>\r\n//   Array.isArray(data) && data.every(el => typeof el === 'string')\r\n\r\n// onmessage = function ({ data: bottlesAsString }: MessageEvent<string>) {\r\n//   console.log('hello from worker')\r\n\r\n//   let bottles: Bottle[]\r\n//   try {\r\n//     bottles = JSON.parse(bottlesAsString)\r\n\r\n//     if (!isArrayOfStrings(bottles)) throw new Error('Invalid input data')\r\n//   } catch (err: any) {\r\n//     postMessage({ error: err.message })\r\n//     return\r\n//   }\r\n\r\n//   new SolutionSearch(bottles, solution => postMessage({ solution }))\r\n\r\n//   postMessage({ finished: true })\r\n// }\r\n\r\nonmessage = function (bottlesAsString: MessageEvent<string>) {\r\n  console.log('hello from worker')\r\n  const bottles: Bottle[] = JSON.parse(bottlesAsString.data)\r\n\r\n  let foundSolution = false\r\n\r\n  new SolutionSearch(bottles, solution => {\r\n    foundSolution = true\r\n    postMessage(solution)\r\n  })\r\n\r\n  if (!foundSolution) postMessage([])\r\n}\r\n"],"names":["$b3daf550d72d25c2$var$getTopColor","bottle","length","$b3daf550d72d25c2$export$21c597f58d486f9","$b3daf550d72d25c2$var$hasOnlyOneColor","$b3daf550d72d25c2$var$canPour","fromBottle","toBottle","color","$b3daf550d72d25c2$export$74c27a9c882a3f71","$b3daf550d72d25c2$var$shodPour","push","pop","emptiedBottle","filledBottle","$b3daf550d72d25c2$export$912ebf39a4c23e9f","bottle1","bottle2","i","$17975fa0d9a06ffd$export$2e2bcd8739ae039","key","parent","this","children","_hasUniqueKeyInBranch","areEqualKeys","ancestorNode","hasUniqueKeyInBranch","getBranchKeys","ancestryKeys","branchNode","reverse","$6531d5bf0b162d50$export$2eac8ed453703230","step1","step2","$6531d5bf0b162d50$export$56be50c673886d51","step","reduce","sum","$8cdb48ed8e58468e$export$2e2bcd8739ae039","bottles","onFindSolution","bestMoveCount","Number","MAX_SAFE_INTEGER","foundASolution","closedBottlesPreStepInFoundSolution","search","undefined","removeLastAddedNodeFromParent","node","saveSearchProgress","solution","map","madeProgress","stepIndex","moveCount","$c9e0023f02f54297$export$c7a6dae52d455f73","forEach","j","changedBottles","nextStep","newNode","onmessage","bottlesAsString","console","log","JSON","parse","data","foundSolution","postMessage"],"version":3,"file":"worker.js.map"}